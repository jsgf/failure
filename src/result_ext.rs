use core::fmt::Display;

use {Fail, FailError, Chain, Compat, Context};

/// Extension methods for `Result`.
pub trait ResultExt<T, E> {
    /// Type of a chained error
    type ChainedErr: Fail;

    /// Wraps the error in `Compat` to make it compatible with older error
    /// handling APIs that expect `std::error::Error`.
    fn compat(self) -> Result<T, Compat<E>>;

    /// Wraps the error type in a context type.
    fn context<D>(self, context: D) -> Result<T, Context<D>>
    where
        D: Display + Send + Sync + 'static;

    /// Chains a description of the circumstances of an error
    /// This allows a causal chain to be constructed for an error.
    fn chain_err<D>(self, context: D) -> Result<T, Chain<D, Self::ChainedErr>>
    where
        D: Display + Send + Sync + 'static;

    /// Wraps the error type in a context type generated by looking at the
    /// error value.
    fn with_context<F, D>(self, f: F) -> Result<T, Context<D>>
    where
        F: FnOnce(&E) -> D,
        D: Display + Send + Sync + 'static;
}

impl<T, E> ResultExt<T, E> for Result<T, E>
where
    E: Fail,
{
    type ChainedErr = E;

    fn compat(self) -> Result<T, Compat<E>> {
        self.map_err(|err| err.compat())
    }

    fn context<D>(self, context: D) -> Result<T, Context<D>>
    where
        D: Display + Send + Sync + 'static,
    {
        self.map_err(|failure| failure.context(context))
    }

    fn chain_err<D>(self, msg: D) -> Result<T, Chain<D, E>> {
        self.map_err(|err| Chain::new(err, msg))
    }

    fn with_context<F, D>(self, f: F) -> Result<T, Context<D>>
    where
        F: FnOnce(&E) -> D,
        D: Display + Send + Sync + 'static,
    {
        self.map_err(|failure| {
            let context = f(&failure);
            failure.context(context)
        })
    }
}

with_std! {
    use Error;

    impl<T> ResultExt<T, Error> for Result<T, Error> {
        type ChainedErr = FailError;

        fn compat(self) -> Result<T, Compat<Error>> {
            self.map_err(|err| err.compat())
        }

        fn context<D>(self, context: D) -> Result<T, Context<D>> where
            D: Display + Send + Sync + 'static
        {
            self.map_err(|failure| failure.context(context))
        }

        fn chain_err<D>(self, msg: D) -> Result<T, Chain<D, Self::ChainedErr>> {
            self.map_err(|err| Chain::new(FailError::from(err), msg))
        }

        fn with_context<F, D>(self, f: F) -> Result<T, Context<D>> where
            F: FnOnce(&Error) -> D,
            D: Display + Send + Sync + 'static
        {
            self.map_err(|failure| {
                let context = f(&failure);
                failure.context(context)
            })
        }
    }
}
